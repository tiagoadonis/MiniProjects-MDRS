clear all;
close all;

Nodes= [30 70
       350 40
       550 180
       310 130
       100 170
       540 290
       120 240
       400 310
       220 370
       550 380];
   
Links= [1 2
        1 5
        2 3
        2 4
        3 4
        3 6
        3 8
        4 5
        4 8
        5 7
        6 8
        6 10
        7 8
        7 9
        8 9
        9 10];

T= [1  3  1.0 1.0
    1  4  0.7 0.5
    2  7  2.4 1.5
    3  4  2.4 2.1
    4  9  1.0 2.2
    5  6  1.2 1.5
    5  8  2.1 2.5
    5  9  1.6 1.9
    6 10  1.4 1.6];

nNodes= 10;
nLinks= size(Links,1);
nFlows= size(T,1);
co= Nodes(:,1)+j*Nodes(:,2);

% Square matrix with arc lengths (in Km) : matriz com os comprimentos de 
% cada ligacao ij ou infinito se a ligacao nao existir, com a diagonal a zeros
L= inf(nNodes);   
for i=1:nNodes
    L(i,i)= 0;
end
for i=1:nLinks
    d= abs(co(Links(i,1))-co(Links(i,2)));
    L(Links(i,1),Links(i,2))= d+5; %Km
    L(Links(i,2),Links(i,1))= d+5; %Km
end
L= round(L);  %Km

% Compute up to n paths for each flow:
n= inf;
[sP nSP]= calculatePaths(L,T,n);    % quero todos os percursos, do mais curto para o mais longo


% ------------------------------- TASK 2.b -------------------------------
% Run a greedy randomized algorithm during 10 seconds in three cases: 
% (i) using all possible routing paths, 
% (ii) using the 10 shortest routing paths, and 
% (iii) using the 5 shortest routing paths. 
% For each case, register the energy consumption value of the best solution, 
% the number of solutions generated by the algorithm and the average quality
% of all solutions. On a single figure, plot for the three cases the worst 
% link load values of all solutions in an increasing order. Take conclusions 
% on the influence of the number of routing paths in the efficiency of 
% the random algorithm.
fprintf('------------------------------- 2.b -------------------------------\n');
fprintf('GREEDY RANDOMIZED STRATEGY\n');

fprintf('   Using all possible routing paths:\n');
n = inf;
% Compute up to n paths for each flow:
[sP nSP] = calculatePaths(L,T,n);                                     % nSP(i) = nº de percursos num fluxo
% Optimization algorithm resorting to the GREEDY RANDOMIZED strategy
time = 10;
t = tic;
bestEnergy = inf;                                                          % valor da melhor solucao   
allValues = [];                                                          % vetor onde se guarda os valores de todas as solucoes
while toc(t) < time                                                       % percorrer ate a condicao time ser atingida
    continuar = true;
    while continuar
        continuar = false;
        ax2 = randperm(nFlows);                                              % escolher uma ordem aleatoria, para cada fluxo por essa ordem, escolher a funcao objetivo
        sol = zeros(1,nFlows);                                               % dimensao = nº de fluxos, conteudo = 2, segundo percurso (p.e)
        for i = ax2
            k_best = 0;
            best = inf;
            for k = 1:nSP(i)                                                 % nSp(i) = numero de percursos para o fluxo i
                sol(i) = k;      
                Loads = calculateLinkLoads(nNodes,Links,T,sP,sol);           % calcular as cargas da solucao gerada
                load = max(max(Loads(:,3:4)));                               % verificar o maior valor das cargas entre a 3 e 4 colunas
                if load <= 10
                    energy = 0;
                    for a = 1:nLinks
                        if Loads(a,3)+Loads(a,4) > 0
                            energy = energy + L(Loads(a,1),Loads(a,2));
                        end
                    end
                else
                    energy = inf;
                end
                if energy < best
                    k_best = k;
                    best = energy;
                end
            end
            if k_best > 0
                sol(i) = k_best;
            else
                continuar = true;
                break;
            end
        end
    end
    energy = best;
    allValues = [allValues energy];
    if energy < bestEnergy
        bestSol = sol;
        bestEnergy = energy;
    end
end
fprintf('      Best energy = %.1f Km\n', bestEnergy);
fprintf('      No. of solutions = %d\n', length(allValues));
fprintf('      Av. quality of solutions = %.1f Km\n\n', mean(allValues));
figure(2);
hold on
plot(sort(allValues)); 


fprintf('   Using 10 shortest routing paths:\n');
n = 10;
[sP nSP] = calculatePaths(L,T,n);    
time = 10;
t = tic;
bestEnergy = inf;  
allValues = [];    
while toc(t) < time            
    continuar = true;
    while continuar
        continuar = false;
        ax2 = randperm(nFlows);     
        sol = zeros(1,nFlows);    
        for i = ax2
            k_best = 0;
            best = inf;
            for k = 1:nSP(i)    
                sol(i) = k;      
                Loads = calculateLinkLoads(nNodes,Links,T,sP,sol);      
                load = max(max(Loads(:,3:4)));   
                if load <= 10
                    energy = 0;
                    for a = 1:nLinks
                        if Loads(a,3)+Loads(a,4) > 0
                            energy = energy + L(Loads(a,1),Loads(a,2));
                        end
                    end
                else
                    energy = inf;
                end
                if energy < best     
                    k_best = k;
                    best = energy;
                end
            end
            if k_best > 0
                sol(i) = k_best;
            else
                continuar = true;
                break;
            end
        end
    end
    energy = best;
    allValues = [allValues energy];
    if energy < bestEnergy
        bestSol = sol;
        bestEnergy = energy;
    end
end
fprintf('      Best energy = %.1f Km\n', bestEnergy);
fprintf('      No. of solutions = %d\n', length(allValues));
fprintf('      Av. quality of solutions = %.1f Km\n\n', mean(allValues));
figure(2);
hold on
plot(sort(allValues)); 



fprintf('   Using 5 shortest routing paths:\n');
n = 5;
[sP nSP] = calculatePaths(L,T,n);  
time = 10;
t = tic;
bestEnergy = inf;  
allValues = [];          
while toc(t) < time     
    continuar = true;
    while continuar
        continuar = false;
        ax2 = randperm(nFlows);     
        sol = zeros(1,nFlows);    
        for i = ax2
            k_best = 0;
            best = inf;
            for k = 1:nSP(i)  
                sol(i) = k;      
                Loads = calculateLinkLoads(nNodes,Links,T,sP,sol);   
                load = max(max(Loads(:,3:4)));  
                if load <= 10
                    energy = 0;
                    for a = 1:nLinks
                        if Loads(a,3)+Loads(a,4) > 0
                            energy = energy + L(Loads(a,1),Loads(a,2));
                        end
                    end
                else
                    energy = inf;
                end
                if energy < best 
                    k_best = k;
                    best = energy;
                end
            end
            if k_best > 0
                sol(i) = k_best;
            else
                continuar = true;
                break;
            end
        end
    end
    energy = best;
    allValues = [allValues energy];
    if energy < bestEnergy
        bestSol = sol;
        bestEnergy = energy;
    end
end
fprintf('      Best energy = %.1f Km\n', bestEnergy);
fprintf('      No. of solutions = %d\n', length(allValues));
fprintf('      Av. quality of solutions = %.1f Km\n\n', mean(allValues));
figure(2);
hold on
plot(sort(allValues)); 
title({'Greedy Randomized algorithm'}, {'to minimize the energy consumption of the network'});
xlabel('No. of solutions');
ylabel('Best energy (Km)');  
legend('All possible routing paths','10 shortest routing paths','5 shortest routing paths','Location','southeast');